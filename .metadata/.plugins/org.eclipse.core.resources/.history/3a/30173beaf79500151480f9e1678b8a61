import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import lejos.hardware.Button;
import lejos.hardware.Sound;
import lejos.hardware.lcd.LCD;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfRect;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.highgui.Highgui;
import org.opencv.highgui.VideoCapture;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;

/**
 * A class to detect and track faces streamed from a webcam
 * Keeps track of the x,y of the faces and can be queried
 * 
 * @author mcrosbie
 *
 */
class DetectFace {

	private int frameCount = 0;
	private CascadeClassifier faceDetector;
	
	private int flags = 0;
	private double scaleFactor = 1.8;
	private int minNeighbours = 2;
    private Size minSize = new Size(10,10);
    private Size maxSize = new Size(320,240);
    private final String HaarFeatures = "/haarcascade_frontalface_alt.xml";  //classifiers to detect eyes and face.
    private final String LbpFeatures = "/lbpcascade_frontalface.xml";
    private String features;
    
    /**
     * Default constructor uses the LBP feature detector - faster but less accurate
     * and sets scaleFactor and minNeighbours
     */
    public DetectFace() {
    	features = LbpFeatures;
    }
    
    /**
     * 
     * @param _flags Flags value
     * @param _scale scaleFactor
     * @param _minNeighbours
     * @param _features which feature file to use
     */
    public DetectFace(int _flags, double _scale, int _minNeighbours, String _features) {
    	flags = _flags;
    	scaleFactor = _scale;
    	minNeighbours = _minNeighbours;
    	features = _features;
    }
    
	public void run() throws Exception {
		
	    Mat frame = new Mat();
	    
        VideoCapture vid = new VideoCapture(0);
        vid.set(Highgui.CV_CAP_PROP_FRAME_WIDTH, 160);
        vid.set(Highgui.CV_CAP_PROP_FRAME_HEIGHT, 120);
        vid.open(0);
        
        faceDetector = new CascadeClassifier(getClass().getResource(features).getPath());

        if(faceDetector.empty()) {
        	System.err.println("Failed to load classifier ");
        	Sound.buzz();
        	System.exit(1);
        } 

          
        /**
         * Capture images and stream to the web client
         */
        while (Button.ESCAPE.isUp()) {
            
        	vid.read(frame);     	
        	
        	Point midPoint1 = new Point((double)(frame.width()/2), 0.0);
        	Point midPoint2 = new Point((double)(frame.width()/2), (double)frame.height());
        	
            if (!frame.empty()) {
            	           	
                MatOfRect faces = new MatOfRect();
                Mat mRgba=new Mat();  
                Mat mGrey=new Mat();  
                frame.copyTo(mRgba);  
                frame.copyTo(mGrey);  
                Imgproc.cvtColor( mRgba, mGrey, Imgproc.COLOR_BGR2GRAY);  
                Imgproc.equalizeHist( mGrey, mGrey );                  
                
                // detect faces
                faceDetector.detectMultiScale(
                		mGrey, 
                		faces,
                		scaleFactor,
                		minNeighbours,
                		flags,
                		minSize,
                		maxSize);

               	// draw a line down the middle of the frame so we can tell left from right
            	Core.line(frame, midPoint1, midPoint2, new Scalar(255, 0, 0, 255), 1);

                int numFaces = faces.toArray().length;
                if(numFaces > 0) {

		            // each rectangle in faces is a face
		            Rect[] facesArray = faces.toArray();
		            Point[] centres = new Point[facesArray.length];
		            
		            for (int i = 0; i < facesArray.length; i++) {
		            	Rect rect = facesArray[i];
		                centres[i]= new Point(rect.x + rect.width*0.5, rect.y + rect.height*0.5 );  
		            }
                } 
             }
        }
	}
}